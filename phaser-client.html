<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Multiplayer Agar.io Clone</title>
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #222;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    #game-container {
      position: relative;
      width: 100%;
      height: 100%;
    }
    #username-form {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.8);
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      z-index: 10;
      text-align: center;
      color: white;
      min-width: 300px;
    }
    #username-form h2 {
      margin-top: 0;
      color: #4CAF50;
    }
    #username-form input {
      padding: 12px;
      margin: 15px 0;
      width: 100%;
      border: none;
      border-radius: 5px;
      background-color: rgba(255, 255, 255, 0.9);
      font-size: 16px;
      box-sizing: border-box;
    }
    #username-form button {
      padding: 12px 25px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      transition: background-color 0.3s;
    }
    #username-form button:hover {
      background-color: #45a049;
    }
    #ui-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
    }
    #leaderboard {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
      color: white;
      min-width: 200px;
      pointer-events: auto;
    }
    #leaderboard h3 {
      margin-top: 0;
      text-align: center;
      color: #4CAF50;
      border-bottom: 1px solid #4CAF50;
      padding-bottom: 5px;
    }
    #leaderboard-content div {
      padding: 3px 0;
    }
    #score-display {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
      color: white;
      pointer-events: auto;
    }
    #connection-status {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 8px 12px;
      border-radius: 5px;
      color: white;
      font-size: 14px;
    }
    #debug-toggle {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background-color: #333;
      color: white;
      border: none;
      border-radius: 5px;
      padding: 8px 12px;
      cursor: pointer;
      font-weight: bold;
      pointer-events: auto;
    }
    .highlight {
      color: #4CAF50;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="username-form">
      <h2>Enter Your Username</h2>
      <input type="text" id="username-input" placeholder="Username" maxlength="15">
      <button id="start-button">Start Game</button>
    </div>
    <div id="ui-container">
      <div id="leaderboard">
        <h3>Leaderboard</h3>
        <div id="leaderboard-content"></div>
      </div>
      <div id="score-display">
        <div>Score: <span id="score-value" class="highlight">0</span></div>
        <div>Size: <span id="size-value" class="highlight">20</span></div>
      </div>
      <div id="connection-status">Disconnected</div>
      <button id="debug-toggle">Debug: OFF</button>
    </div>
  </div>

  <script>
    class Game {
      constructor() {
        // Configuration
        this.backendUrl = "__BACKEND_URL__";
        // Check if the placeholder was not replaced during deployment
        if (this.backendUrl === "__BACKEND_URL__") {
          // Local development fallback
          if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            this.backendUrl = "http://localhost:3000";
          }
        }
        
        // Determine if we're in production
        this.isProduction = this.backendUrl !== "http://localhost:3000";
        
        this.socket = null;
        this.username = '';
        this.gameStarted = false;
        this.debugMode = false;
        
        // Game state
        this.playerSize = 20;
        this.playerScore = 0;
        this.players = {};
        this.food = [];
        this.worldSize = { width: 2000, height: 2000 };
        this.gridCells = {};
        this.gridSize = 200;
        
        // Client-side prediction
        this.lastMoveSent = { vx: 0, vy: 0, timestamp: 0 };
        this.pendingInputs = [];
        this.serverUpdateRate = 1000 / 30; // Server update rate in ms
        this.lastServerUpdate = 0;
        
        // Direct movement system
        this.movementTarget = null; // Target position for movement
        this.movementSpeed = 5; // Base movement speed
        this.lastPosition = { x: 0, y: 0 }; // Last position for prediction
        
        // Entity caching for smooth transitions
        this.entityCache = {
          players: {}, // Format: {id: {entity, lastSeen, alpha}}
          food: {}     // Format: {id: {entity, lastSeen, alpha}}
        };
        this.cacheLifetime = 1000; // How long to keep entities in cache after they disappear (ms)
        this.fadeSpeed = 0.1;      // How quickly entities fade in/out (alpha change per frame)
        
        // DOM Elements
        this.usernameForm = document.getElementById('username-form');
        this.usernameInput = document.getElementById('username-input');
        this.startButton = document.getElementById('start-button');
        this.leaderboardContent = document.getElementById('leaderboard-content');
        this.scoreValue = document.getElementById('score-value');
        this.sizeValue = document.getElementById('size-value');
        this.connectionStatus = document.getElementById('connection-status');
        this.debugToggle = document.getElementById('debug-toggle');
        
        // Phaser game instance
        this.phaserGame = null;
        
        // Initialize
        this.init();
      }
      
      init() {
        // Set up event listeners
        this.startButton.addEventListener('click', () => this.startGame());
        
        // Only show debug toggle in development
        if (this.isProduction) {
          this.debugToggle.style.display = 'none';
        } else {
          this.debugToggle.addEventListener('click', () => this.toggleDebug());
        }
        
        // Initialize Phaser game
        this.initPhaser();
      }
      
      initPhaser() {
        const config = {
          type: Phaser.AUTO,
          width: window.innerWidth,
          height: window.innerHeight,
          parent: 'game-container',
          backgroundColor: '#000000',
          scene: {
            preload: this.preload.bind(this),
            create: this.create.bind(this),
            update: this.update.bind(this)
          },
          physics: {
            default: 'arcade',
            arcade: {
              debug: false
            }
          },
          input: {
            activePointers: 2, // Support multi-touch
            touch: {
              capture: true
            }
          }
        };
        
        this.phaserGame = new Phaser.Game(config);
        
        // Handle window resize
        window.addEventListener('resize', () => {
          if (this.phaserGame) {
            this.phaserGame.scale.resize(window.innerWidth, window.innerHeight);
          }
        });
      }
      
      startGame() {
        this.username = this.usernameInput.value.trim() || 'Player';
        if (this.username) {
          this.usernameForm.style.display = 'none';
          this.connectToServer();
        }
      }
      
      connectToServer() {
        try {
          console.log('Connecting to server at:', this.backendUrl);
          this.updateConnectionStatus('Connecting...', '#ffcc00');
          
          this.socket = io(this.backendUrl, {
            reconnection: true,
            reconnectionAttempts: 5,
            reconnectionDelay: 1000,
            timeout: 5000
          });
          
          // Set up socket event handlers
          this.socket.on('connect', () => this.handleConnect());
          this.socket.on('connect_error', (error) => this.handleConnectError(error));
          this.socket.on('gameState', (state) => this.handleGameState(state));
          this.socket.on('absorbed', () => this.handleAbsorbed());
          this.socket.on('disconnect', () => this.handleDisconnect());
        } catch (error) {
          console.error('Error connecting to server:', error);
          this.updateConnectionStatus('Connection error', '#ff0000');
        }
      }
      
      handleConnect() {
        console.log('Connected to server as:', this.socket.id);
        this.updateConnectionStatus('Connected', '#4CAF50');
        this.gameStarted = true;
        
        // Join the game with initial position and viewport size
        const startX = Math.random() * (this.worldSize.width - 100) + 50;
        const startY = Math.random() * (this.worldSize.height - 100) + 50;
        
        this.socket.emit('joinGame', { 
          x: startX, 
          y: startY, 
          radius: this.playerSize, 
          username: this.username,
          viewportWidth: window.innerWidth,
          viewportHeight: window.innerHeight
        });
        
        // Send viewport size when window is resized
        window.addEventListener('resize', () => {
          if (this.socket && this.gameStarted) {
            this.socket.emit('updateViewport', {
              width: window.innerWidth,
              height: window.innerHeight
            });
          }
        });
        
        console.log('Join game request sent');
      }
      
      handleConnectError(error) {
        console.error('Connection error:', error);
        this.updateConnectionStatus('Connection error', '#ff0000');
      }
      
      handleGameState(state) {
        // Store timestamp of server update
        this.lastServerUpdate = Date.now();
        
        if (state.fullUpdate === true) {
          // Handle full update
          this.players = state.players;
          this.food = state.food;
          this.fullPlayerCount = state.fullPlayerCount || Object.keys(state.players).length;
          this.gridCells = state.gridCells || {};
          this.gridSize = state.gridSize || 200;
          this.visibleCellsX = state.visibleCellsX || 0;
          this.visibleCellsY = state.visibleCellsY || 0;
          this.leaderboardData = state.leaderboard || [];
        } else {
          // Handle delta update
          
          // Update players with delta
          if (state.playersDelta) {
            for (const id in state.playersDelta) {
              this.players[id] = state.playersDelta[id];
            }
          }
          
          // Remove players that are no longer visible
          if (state.removedPlayers) {
            for (const id of state.removedPlayers) {
              delete this.players[id];
            }
          }
          
          // Add new food
          if (state.newFood) {
            // Add new food items to the existing array
            this.food = this.food.filter(food => 
              !state.removedFood || !state.removedFood.includes(food.id)
            ).concat(state.newFood);
          }
          
          // Update other state properties
          if (state.fullPlayerCount !== undefined) {
            this.fullPlayerCount = state.fullPlayerCount;
          }
          
          if (state.leaderboard) {
            this.leaderboardData = state.leaderboard;
          }
        }
        
        // If we have our own player data, reconcile with client-side prediction
        if (this.socket && this.players[this.socket.id]) {
          this.reconcileClientPrediction(this.players[this.socket.id]);
        }
        
        // Mark all current entities as seen
        const now = Date.now();
        
        // Update player cache
        Object.keys(this.players).forEach(id => {
          if (!this.entityCache.players[id]) {
            // New player - add to cache with fade-in
            this.entityCache.players[id] = {
              entity: this.players[id],
              lastSeen: now,
              alpha: 0 // Start invisible and fade in
            };
          } else {
            // Existing player - update data and mark as seen
            this.entityCache.players[id].entity = this.players[id];
            this.entityCache.players[id].lastSeen = now;
            // If fading in, continue fade in, otherwise set to fully visible
            if (this.entityCache.players[id].alpha < 1) {
              // Continue fading in
            } else {
              this.entityCache.players[id].alpha = 1;
            }
          }
        });
        
        // Update food cache
        this.food.forEach(food => {
          if (!this.entityCache.food[food.id]) {
            // New food - add to cache with fade-in
            this.entityCache.food[food.id] = {
              entity: food,
              lastSeen: now,
              alpha: 0 // Start invisible and fade in
            };
          } else {
            // Existing food - update data and mark as seen
            this.entityCache.food[food.id].entity = food;
            this.entityCache.food[food.id].lastSeen = now;
            // If fading in, continue fade in, otherwise set to fully visible
            if (this.entityCache.food[food.id].alpha < 1) {
              // Continue fading in
            } else {
              this.entityCache.food[food.id].alpha = 1;
            }
          }
        });
        
        // Update player data if exists
        if (this.players[this.socket.id]) {
          this.playerScore = this.players[this.socket.id].score || 0;
          this.playerSize = this.players[this.socket.id].radius || 20;
          
          // Update UI
          this.scoreValue.textContent = Math.floor(this.playerScore);
          this.sizeValue.textContent = this.playerSize.toFixed(1);
        }
        
        // Update leaderboard
        this.updateLeaderboard();
      }
      
      // New method for client-side prediction reconciliation
      reconcileClientPrediction(serverPlayerState) {
        // Remove processed inputs
        const now = Date.now();
        this.pendingInputs = this.pendingInputs.filter(input => {
          return input.timestamp > serverPlayerState.lastUpdate;
        });
        
        // If server position is significantly different from our position, update immediately
        const currentX = this.players[this.socket.id].x;
        const currentY = this.players[this.socket.id].y;
        
        const diffX = Math.abs(serverPlayerState.x - currentX);
        const diffY = Math.abs(serverPlayerState.y - currentY);
        
        // If difference is significant, snap to server position
        if (diffX > 20 || diffY > 20) {
          this.players[this.socket.id].x = serverPlayerState.x;
          this.players[this.socket.id].y = serverPlayerState.y;
          
          // Also update last position for prediction
          this.lastPosition = { 
            x: serverPlayerState.x, 
            y: serverPlayerState.y 
          };
          
          console.log("Position corrected by server");
        }
      }
      
      handleAbsorbed() {
        console.log('You have been absorbed!');
        this.gameOver();
      }
      
      handleDisconnect() {
        console.log('Disconnected from server');
        this.updateConnectionStatus('Disconnected', '#ff0000');
        this.gameStarted = false;
      }
      
      updateConnectionStatus(message, color) {
        this.connectionStatus.textContent = message;
        this.connectionStatus.style.color = color;
      }
      
      updateLeaderboard() {
        // Use server-provided leaderboard data
        if (!this.leaderboardData || this.leaderboardData.length === 0) {
          // Fallback to local calculation if server data is not available
          const sortedPlayers = Object.values(this.players)
            .sort((a, b) => b.score - a.score)
            .slice(0, 10);
          
          // Update leaderboard HTML
          this.leaderboardContent.innerHTML = '';
          sortedPlayers.forEach((player, index) => {
            const playerName = player.username || 'Unknown';
            const isCurrentPlayer = player.id === this.socket.id;
            const playerEntry = document.createElement('div');
            playerEntry.textContent = `${index + 1}. ${playerName}: ${Math.floor(player.score)}`;
            if (isCurrentPlayer) {
              playerEntry.style.fontWeight = 'bold';
              playerEntry.style.color = '#4CAF50';
            }
            this.leaderboardContent.appendChild(playerEntry);
          });
        } else {
          // Use server-provided leaderboard data
          this.leaderboardContent.innerHTML = '';
          this.leaderboardData.forEach((player, index) => {
            const playerName = player.username || 'Unknown';
            const playerEntry = document.createElement('div');
            playerEntry.textContent = `${index + 1}. ${playerName}: ${Math.floor(player.score)}`;
            if (player.isCurrentPlayer) {
              playerEntry.style.fontWeight = 'bold';
              playerEntry.style.color = '#4CAF50';
            }
            this.leaderboardContent.appendChild(playerEntry);
          });
        }
      }
      
      gameOver() {
        if (!this.phaserGame || !this.phaserGame.scene.scenes[0]) return;
        
        const scene = this.phaserGame.scene.scenes[0];
        
        // Create a dark overlay for the game over screen
        const overlay = scene.add.rectangle(
          0, 0,
          this.phaserGame.config.width * 2,
          this.phaserGame.config.height * 2,
          0x000000, 0.7
        ).setOrigin(0).setScrollFactor(0).setDepth(999);
        
        // Smoothly transition the camera back to center
        scene.cameras.main.stopFollow();
        scene.cameras.main.pan(
          this.phaserGame.config.width / 2,
          this.phaserGame.config.height / 2,
          1000, // Duration in ms
          'Sine.easeOut'
        );
        
        // Wait for camera transition to complete before showing game over text
        scene.time.delayedCall(1000, () => {
          // Create game over text with animation
          const gameOverText = scene.add.text(
            this.phaserGame.config.width / 2,
            this.phaserGame.config.height / 2 - 50,
            'GAME OVER',
            { 
              fontSize: '48px', 
              fontFamily: 'Arial',
              fontWeight: 'bold',
              fill: '#ff0000', 
              align: 'center',
              stroke: '#000',
              strokeThickness: 6
            }
          ).setOrigin(0.5).setDepth(1000).setScrollFactor(0).setAlpha(0);
          
          // Add score display
          const finalScore = scene.add.text(
            this.phaserGame.config.width / 2,
            this.phaserGame.config.height / 2 + 20,
            `Final Score: ${Math.floor(this.playerScore)}`,
            { 
              fontSize: '32px', 
              fontFamily: 'Arial',
              fill: '#ffffff', 
              align: 'center',
              stroke: '#000',
              strokeThickness: 4
            }
          ).setOrigin(0.5).setDepth(1000).setScrollFactor(0).setAlpha(0);
          
          // Add restart button
          const restartButton = scene.add.text(
            this.phaserGame.config.width / 2,
            this.phaserGame.config.height / 2 + 100,
            'Click to restart',
            { 
              fontSize: '24px', 
              fontFamily: 'Arial',
              fill: '#4CAF50', 
              align: 'center',
              stroke: '#000',
              strokeThickness: 4,
              backgroundColor: '#00000080',
              padding: { x: 20, y: 10 }
            }
          ).setOrigin(0.5).setDepth(1000).setScrollFactor(0).setAlpha(0)
           .setInteractive({ useHandCursor: true });
          
          // Fade in the game over elements
          scene.tweens.add({
            targets: [gameOverText, finalScore, restartButton],
            alpha: 1,
            duration: 500,
            ease: 'Power2'
          });
          
          // Add pulse animation to the restart button
          scene.tweens.add({
            targets: restartButton,
            scaleX: 1.1,
            scaleY: 1.1,
            duration: 800,
            yoyo: true,
            repeat: -1,
            ease: 'Sine.easeInOut'
          });
          
          // Handle restart
          restartButton.on('pointerdown', () => {
            // Fade out everything
            scene.tweens.add({
              targets: [gameOverText, finalScore, restartButton, overlay],
              alpha: 0,
              duration: 300,
              onComplete: () => {
                // Clean up
                gameOverText.destroy();
                finalScore.destroy();
                restartButton.destroy();
                overlay.destroy();
                
                // Show username form
                this.usernameForm.style.display = 'block';
                
                // Disconnect socket
                if (this.socket) {
                  this.socket.disconnect();
                }
                
                this.gameStarted = false;
              }
            });
          });
        });
      }
      
      toggleDebug() {
        this.debugMode = !this.debugMode;
        
        if (this.phaserGame && this.phaserGame.scene.scenes[0]) {
          const scene = this.phaserGame.scene.scenes[0];
          
          if (scene.debugGraphics) {
            scene.debugGraphics.setVisible(this.debugMode);
          }
          
          if (scene.debugText) {
            scene.debugText.setVisible(this.debugMode);
          }
        }
        
        // Update button appearance
        if (this.debugMode) {
          this.debugToggle.style.backgroundColor = '#4CAF50';
          this.debugToggle.textContent = 'Debug: ON';
        } else {
          this.debugToggle.style.backgroundColor = '#333';
          this.debugToggle.textContent = 'Debug: OFF';
        }
      }
      
      // Phaser game methods
      preload() {
        const scene = this.phaserGame.scene.scenes[0];
        
        // Load game assets from CDN
        scene.load.image('player', 'https://raw.githubusercontent.com/photonstorm/phaser3-examples/master/public/assets/sprites/orb-blue.png');
        scene.load.image('enemy', 'https://raw.githubusercontent.com/photonstorm/phaser3-examples/master/public/assets/sprites/orb-red.png');
        scene.load.image('food', 'https://raw.githubusercontent.com/photonstorm/phaser3-examples/master/public/assets/sprites/orb-green.png');
        scene.load.image('background', 'https://raw.githubusercontent.com/photonstorm/phaser3-examples/master/public/assets/skies/space3.png');
      }
      
      create() {
        const scene = this.phaserGame.scene.scenes[0];
        
        // Create main game container
        scene.gameContainer = scene.add.container(0, 0);
        
        // Create background
        scene.background = scene.add.tileSprite(0, 0, this.worldSize.width, this.worldSize.height, 'background')
          .setOrigin(0, 0)
          .setAlpha(0.5);
        scene.gameContainer.add(scene.background);
        
        // Create static grid lines
        const staticGridGraphics = scene.add.graphics();
        staticGridGraphics.lineStyle(1, 0xcccccc, 0.3);
        
        // Draw vertical grid lines
        for (let x = 0; x < this.worldSize.width; x += 100) {
          staticGridGraphics.moveTo(x, 0);
          staticGridGraphics.lineTo(x, this.worldSize.height);
        }
        
        // Draw horizontal grid lines
        for (let y = 0; y < this.worldSize.height; y += 100) {
          staticGridGraphics.moveTo(0, y);
          staticGridGraphics.lineTo(this.worldSize.width, y);
        }
        
        // Draw world boundary
        staticGridGraphics.lineStyle(3, 0xff0000, 0.8);
        staticGridGraphics.strokeRect(0, 0, this.worldSize.width, this.worldSize.height);
        
        staticGridGraphics.strokePath();
        scene.gameContainer.add(staticGridGraphics);
        
        // Create grid container for dynamic grid visualization
        scene.gridContainer = scene.add.container(0, 0);
        scene.gameContainer.add(scene.gridContainer);
        
        // Create containers for game objects
        scene.foodContainer = scene.add.container(0, 0);
        scene.otherPlayersContainer = scene.add.container(0, 0);
        
        // Create player container
        scene.playerContainer = scene.add.container(0, 0);
        scene.playerSprite = scene.add.sprite(0, 0, 'player');
        scene.playerSprite.setVisible(false); // Initially hidden until we have player data
        scene.playerContainer.add(scene.playerSprite);
        
        // Add player name text
        scene.playerNameText = scene.add.text(0, -30, this.username, { 
          fontSize: '16px', 
          fill: '#fff',
          stroke: '#000',
          strokeThickness: 3
        }).setOrigin(0.5);
        scene.playerContainer.add(scene.playerNameText);
        
        // Add containers to main game container
        scene.gameContainer.add(scene.foodContainer);
        scene.gameContainer.add(scene.otherPlayersContainer);
        scene.gameContainer.add(scene.playerContainer);
        
        // Set up camera
        scene.cameras.main.setBounds(0, 0, this.worldSize.width, this.worldSize.height);
        
        // Add debug elements only in development mode
        if (!this.isProduction) {
          scene.debugGraphics = scene.add.graphics().setScrollFactor(0).setDepth(1000).setVisible(this.debugMode);
          
          scene.debugText = scene.add.text(
            20,
            20,
            'Debug Info',
            { 
              fontSize: '16px', 
              fill: '#ffff00', 
              backgroundColor: '#000000',
              padding: { x: 10, y: 10 }
            }
          ).setScrollFactor(0).setDepth(1000).setVisible(this.debugMode);
        }
        
        // Set up cursor keys for movement
        scene.cursors = scene.input.keyboard.createCursorKeys();
        
        // Enhance touch controls for mobile
        scene.input.on('pointerdown', (pointer) => {
          scene.isPointerDown = true;
          scene.activePointer = pointer;
        });
        
        scene.input.on('pointermove', (pointer) => {
          if (scene.isPointerDown) {
            scene.activePointer = pointer;
          }
        });
        
        scene.input.on('pointerup', () => {
          scene.isPointerDown = false;
        });
      }
      
      update() {
        if (!this.gameStarted || !this.socket) return;
        
        const scene = this.phaserGame.scene.scenes[0];
        
        // Get player data
        const playerData = this.players[this.socket.id];
        if (!playerData) return;
        
        // Update player sprite and container
        scene.playerSprite.setVisible(true);
        scene.playerSprite.setScale(playerData.radius / 25);
        
        // Update player container position
        scene.playerContainer.setPosition(playerData.x, playerData.y);
        
        // Update player name text
        scene.playerNameText.setText(this.username);
        scene.playerNameText.setPosition(0, -playerData.radius - 10);
        
        // Center camera on player
        scene.cameras.main.centerOn(playerData.x, playerData.y);
        
        // Draw grid cells if debug mode is on
        this.updateGridVisualization(scene);
        
        // Update debug info only in development mode
        if (!this.isProduction && this.debugMode && scene.debugText) {
          const playerCount = Object.keys(this.players).length;
          const otherPlayerCount = playerCount > 0 ? playerCount - 1 : 0;
          const visiblePercent = this.fullPlayerCount > 0 ? 
            Math.round((playerCount / this.fullPlayerCount) * 100) : 100;
          const visibleCells = Object.keys(this.gridCells || {}).length;
          const totalCells = 100; // 10x10 grid
          const viewportCellsX = Math.ceil(window.innerWidth / this.gridSize) + 2;
          const viewportCellsY = Math.ceil(window.innerHeight / this.gridSize) + 2;
          const timeSinceLastUpdate = Date.now() - this.lastServerUpdate;
          
          scene.debugText.setText(`
            FPS: ${Math.round(this.phaserGame.loop.actualFps)}
            Players: ${playerCount} visible of ${this.fullPlayerCount} total (${visiblePercent}%)
            Food: ${this.food.length}
            Grid Cells: ${visibleCells} visible of ${totalCells} total
            Viewport: ${window.innerWidth}x${window.innerHeight} (${viewportCellsX}x${viewportCellsY} cells)
            Server Grid: ${this.visibleCellsX}x${this.visibleCellsY} cells
            Position: (${Math.round(playerData.x)}, ${Math.round(playerData.y)})
            Cell: ${Math.floor(playerData.x/this.gridSize)},${Math.floor(playerData.y/this.gridSize)}
            Size: ${playerData.radius.toFixed(1)}
            Score: ${playerData.score}
            Socket ID: ${this.socket.id}
            Last Server Update: ${timeSinceLastUpdate}ms ago
            Pending Inputs: ${this.pendingInputs.length}
            Movement Target: ${this.movementTarget ? `(${Math.round(this.movementTarget.x)}, ${Math.round(this.movementTarget.y)})` : 'None'}
          `);
        }
        
        // Handle player movement input
        let vx = 0;
        let vy = 0;
        
        // Keyboard controls
        if (scene.cursors.left.isDown) {
          vx = -this.movementSpeed;
          this.movementTarget = null; // Cancel any touch/mouse target when using keyboard
        } else if (scene.cursors.right.isDown) {
          vx = this.movementSpeed;
          this.movementTarget = null; // Cancel any touch/mouse target when using keyboard
        }
        
        if (scene.cursors.up.isDown) {
          vy = -this.movementSpeed;
          this.movementTarget = null; // Cancel any touch/mouse target when using keyboard
        } else if (scene.cursors.down.isDown) {
          vy = this.movementSpeed;
          this.movementTarget = null; // Cancel any touch/mouse target when using keyboard
        }
        
        // Touch/mouse controls - completely redesigned for better responsiveness
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const pointer = scene.activePointer || scene.input.activePointer;
        
        // Handle new touch/click
        if ((isTouchDevice && scene.isPointerDown) || (!isTouchDevice && scene.input.activePointer.isDown)) {
          const worldPoint = scene.cameras.main.getWorldPoint(pointer.x, pointer.y);
          
          // Set movement target
          this.movementTarget = {
            x: worldPoint.x,
            y: worldPoint.y
          };
        }
        
        // If we have a movement target, move towards it
        if (this.movementTarget) {
          // Calculate direction vector to target
          const dx = this.movementTarget.x - playerData.x;
          const dy = this.movementTarget.y - playerData.y;
          
          // Calculate distance to target
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          // If we're close enough to the target, stop moving
          if (distance < 5) {
            this.movementTarget = null;
            vx = 0;
            vy = 0;
          } else {
            // Normalize and scale the direction vector
            vx = (dx / distance) * this.movementSpeed;
            vy = (dy / distance) * this.movementSpeed;
          }
        }
        
        const now = Date.now();
        
        // Send movement to server if changed or periodically
        if ((Math.abs(vx) > 0.1 || Math.abs(vy) > 0.1) && 
            (Math.abs(vx - this.lastMoveSent.vx) > 0.1 || 
             Math.abs(vy - this.lastMoveSent.vy) > 0.1 || 
             now - this.lastMoveSent.timestamp > 100)) {
          
          this.socket.emit('move', { vx, vy });
          
          // Store last movement sent
          this.lastMoveSent = { vx, vy, timestamp: now };
          
          // Add to pending inputs for client-side prediction
          this.pendingInputs.push({ vx, vy, timestamp: now });
          
          // Apply movement immediately for client-side prediction
          if (playerData) {
            // Save last position for prediction
            this.lastPosition = { x: playerData.x, y: playerData.y };
            
            // Update position
            playerData.x += vx;
            playerData.y += vy;
            
            // Add boundary checks
            playerData.x = Math.max(playerData.radius, Math.min(this.worldSize.width - playerData.radius, playerData.x));
            playerData.y = Math.max(playerData.radius, Math.min(this.worldSize.height - playerData.radius, playerData.y));
          }
        } else if (Math.abs(vx) < 0.1 && Math.abs(vy) < 0.1 && 
                  (Math.abs(this.lastMoveSent.vx) > 0.1 || Math.abs(this.lastMoveSent.vy) > 0.1)) {
          // Send stop command if we were moving before but now stopped
          this.socket.emit('move', { vx: 0, vy: 0 });
          this.lastMoveSent = { vx: 0, vy: 0, timestamp: now };
          this.movementTarget = null; // Clear movement target when stopped
        }
        
        // Update food sprites
        this.updateFoodSprites(scene);
        
        // Update other player sprites
        this.updateOtherPlayerSprites(scene);
      }
      
      updateFoodSprites(scene) {
        // Clear all food sprites
        scene.foodContainer.removeAll(true);
        
        // Get camera view bounds to only render visible food
        const camera = scene.cameras.main;
        const cameraBounds = {
          left: camera.scrollX - 100,
          right: camera.scrollX + camera.width + 100,
          top: camera.scrollY - 100,
          bottom: camera.scrollY + camera.height + 100
        };
        
        // Process cached food entities
        const now = Date.now();
        Object.keys(this.entityCache.food).forEach(id => {
          const cachedFood = this.entityCache.food[id];
          const food = cachedFood.entity;
          
          // Skip if no valid position
          if (!food || typeof food.x !== 'number' || typeof food.y !== 'number') {
            return;
          }
          
          // Check if food is in view
          const isInView = food.x >= cameraBounds.left && food.x <= cameraBounds.right && 
                          food.y >= cameraBounds.top && food.y <= cameraBounds.bottom;
          
          // Check if food is still in the current game state
          const isActive = this.food.some(f => f.id === id);
          
          // Update alpha based on visibility
          if (isActive && isInView) {
            // Food is active and in view - fade in if needed
            cachedFood.alpha = Math.min(1, cachedFood.alpha + this.fadeSpeed);
          } else {
            // Food is not active or not in view - fade out
            cachedFood.alpha = Math.max(0, cachedFood.alpha - this.fadeSpeed);
          }
          
          // Only render if has some visibility
          if (cachedFood.alpha > 0) {
            // Create food sprite with appropriate alpha
            const sprite = scene.add.sprite(food.x, food.y, 'food');
            sprite.setScale(food.radius / 15);
            sprite.setAlpha(cachedFood.alpha);
            scene.foodContainer.add(sprite);
          }
          
          // Remove from cache if it's been gone too long
          if (!isActive && now - cachedFood.lastSeen > this.cacheLifetime && cachedFood.alpha <= 0) {
            delete this.entityCache.food[id];
          }
        });
      }
      
      updateOtherPlayerSprites(scene) {
        // Clear all other player sprites
        scene.otherPlayersContainer.removeAll(true);
        
        // Get camera view bounds
        const camera = scene.cameras.main;
        const cameraBounds = {
          left: camera.scrollX - 200,
          right: camera.scrollX + camera.width + 200,
          top: camera.scrollY - 200,
          bottom: camera.scrollY + camera.height + 200
        };
        
        // Process cached player entities
        const now = Date.now();
        Object.keys(this.entityCache.players).forEach(id => {
          // Skip the current player
          if (id === this.socket.id) return;
          
          const cachedPlayer = this.entityCache.players[id];
          const player = cachedPlayer.entity;
          
          // Skip if no valid position
          if (!player || typeof player.x !== 'number' || typeof player.y !== 'number') {
            return;
          }
          
          // Check if player is in view
          const isInView = player.x >= cameraBounds.left && player.x <= cameraBounds.right && 
                          player.y >= cameraBounds.top && player.y <= cameraBounds.bottom;
          
          // Check if player is still in the current game state
          const isActive = this.players[id] !== undefined;
          
          // Update alpha based on visibility
          if (isActive && isInView) {
            // Player is active and in view - fade in if needed
            cachedPlayer.alpha = Math.min(1, cachedPlayer.alpha + this.fadeSpeed);
          } else {
            // Player is not active or not in view - fade out
            cachedPlayer.alpha = Math.max(0, cachedPlayer.alpha - this.fadeSpeed);
          }
          
          // Only render if has some visibility
          if (cachedPlayer.alpha > 0) {
            // Create player container
            const playerContainer = scene.add.container(player.x, player.y);
            
            // Create player sprite with appropriate alpha
            const playerSprite = scene.add.sprite(0, 0, 'enemy');
            playerSprite.setScale(player.radius / 25);
            playerSprite.setAlpha(cachedPlayer.alpha);
            playerContainer.add(playerSprite);
            
            // Create player name text with appropriate alpha
            const playerText = scene.add.text(
              0,
              -player.radius - 10,
              player.username || 'Player',
              { 
                fontSize: '16px', 
                fill: '#fff',
                stroke: '#000',
                strokeThickness: 3
              }
            ).setOrigin(0.5);
            playerText.setAlpha(cachedPlayer.alpha);
            playerContainer.add(playerText);
            
            // Add to container
            scene.otherPlayersContainer.add(playerContainer);
          }
          
          // Remove from cache if it's been gone too long
          if (!isActive && now - cachedPlayer.lastSeen > this.cacheLifetime && cachedPlayer.alpha <= 0) {
            delete this.entityCache.players[id];
          }
        });
      }
      
      // Add a new method to update grid visualization
      updateGridVisualization(scene) {
        // Clear previous grid visualization
        scene.gridContainer.removeAll(true);
        
        // Only draw grid in debug mode
        if (!this.debugMode) return;
        
        // Draw grid cells
        for (const cellKey in this.gridCells) {
          const cell = this.gridCells[cellKey];
          
          // Create grid cell rectangle
          const graphics = scene.add.graphics();
          
          // Set style based on cell contents
          if (cell.playerCount > 0 && cell.foodCount > 0) {
            // Both players and food
            graphics.lineStyle(2, 0xffff00, 0.5);
          } else if (cell.playerCount > 0) {
            // Only players
            graphics.lineStyle(2, 0xff0000, 0.5);
          } else if (cell.foodCount > 0) {
            // Only food
            graphics.lineStyle(2, 0x00ff00, 0.5);
          } else {
            // Empty cell
            graphics.lineStyle(2, 0xffffff, 0.2);
          }
          
          // Draw rectangle
          graphics.strokeRect(cell.x, cell.y, cell.width, cell.height);
          
          // Add cell info text if it has entities
          if (cell.playerCount > 0 || cell.foodCount > 0) {
            const text = scene.add.text(
              cell.x + cell.width / 2,
              cell.y + cell.height / 2,
              `P:${cell.playerCount}\nF:${cell.foodCount}`,
              {
                fontSize: '12px',
                fill: '#ffffff',
                align: 'center',
                stroke: '#000000',
                strokeThickness: 2
              }
            ).setOrigin(0.5);
            
            scene.gridContainer.add(text);
          }
          
          scene.gridContainer.add(graphics);
        }
      }
    }
    
    // Initialize the game when the page loads
    window.onload = () => {
      new Game();
    };
  </script>
</body>
</html> 